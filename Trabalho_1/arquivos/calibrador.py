# -*- coding: utf-8 -*-
"""CALIBRADOR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NmyM9b0CgxBMVHKWxHTz4GoPulyvTXcg
"""

from sklearn.metrics import mean_squared_error
import numpy as np
from tqdm import tqdm
import pandas as pd 
import matplotlib.pyplot as plt
import numpy as np

def erro(X):

    z0 = c1_0,c2_0,c3_0,c4_0,c5_0,c6_0,c7_0,c8_0,c9_0
    params = X
    obs = pd.DataFrame()
    
    if reacao == "N":  
      
      sim = amonia(params,z0,)
      
      obs["amonia"] = df["amonia"]
      
      obs["nitrato"] =  df["nitrato"]
      
      obs["n_org"] = df["n_org"]    
      
    elif reacao == "OD":
      sim = OD_DBO(params,z0)
      sim = sim["od"]
      obs = df["od"]
    elif reacao =="fosf":
      sim  = fosforo(params,z0)
      obs["f_org"] = df["f_org"]
      obs["f_inorg"] = df["f_inorg"]
   
    MSE = mean_squared_error(obs, sim)
    
    RMSE = np.sqrt(MSE)
    
    return RMSE

def dds(Xmin, Xmax, fobj, r=0.2, m=500):
    # Passo 1
    
    Xmin = np.asarray(Xmin)
    Xmax = np.asarray(Xmax)
    X0 = (Xmin + Xmax)/2
    D = len(Xmin)
    ds = [i for i in range(D)]
    dX = Xmax - Xmin
    # Passo 2
    I = np.arange(1, m+1, 1)
    Xbest = X0
    Fbest = fobj(Xbest)
    # Passo 3
    for i in tqdm(I):
       
        Pi = 1 - np.log(i)/np.log(m)
        P = np.random.rand(len(Xmin))
        N = np.where(P < Pi)[0]
        
        if N.size == 0:
            N = [np.random.choice(ds)]
        # Passo 4
        Xnew = np.copy(Xbest)
        
        for j in N:
            Xnew[j] = Xbest[j] + r*dX[j]*np.random.normal(0, 1)
            if Xnew[j] < Xmin[j]:
                Xnew[j] = Xmin[j] + (Xmin[j] - Xnew[j])
                if Xnew[j] > Xmax[j]:
                    Xnew[j] = Xmin[j]
            elif Xnew[j] > Xmax[j]:
                Xnew[j] = Xmax[j] - (Xnew[j] - Xmax[j])
                if Xnew[j] < Xmin[j]:
                    Xnew[j] = Xmax[j]
        # Passo 5
        Fnew = fobj(Xnew)
        if Fnew <= Fbest:
            Fbest = Fnew
            Xbest = np.copy(Xnew)
            print(Fbest)
    # Fim
    return Xbest, Fbest

#selecionar o data frame para comparação com os valores simulados, eu escolhi um intervalo de 30 dias pra calibrar

ddados = pd.read_csv("/content/obsevado.csv", sep = ";")
#tratar o data frame, tirei oq fiz, mas tem q deixar ele bonitinho

# constantes iniciais / valores constantes no modelo w = teta
c3_0 = 3.89
c4_0 = 0
c5_0 =1.5000
c9_0=6.9

dd = df.loc[0]
c6_0 = dd[0]
c8_0 = dd[1]
c1_0 = dd[2]
c7_0 = dd[3]
c2_0 = dd[4]

z0 =c1_0,c2_0,c3_0,c4_0,c5_0,c6_0,c7_0,c8_0,c9_0


wg  = 1.066
w = 1.08
wra = 1.08
w2d=1.045  
wd = 1.047
wa = 1.024
fon = 0.5
rpa = 5


kam = 50
ron = 4.571428
roc = 2.6667
#kdbo = 0.5
kdbo = 0.5
h = 5.6

#defino a funcao que quero calibrar
#parametros lower boundrys, limites inferiores para os parametros de fosforo
lb_fo = [0.005,0.1,0.001,0.003,0.001,0.001,0.4,1,2,1,0.1,0.0028,0.2,0.2,0.1,10]
#parametros uper boundrys, limites superiores para os parametros de fosforo
ub_fo = [0.8,0.9,0.36,0.17,0.125,0.8,0.8,2,25,10.9,1.0,0.07,0.8,2.3,1,100]

def fosforo(X,z0,passos = 32,deltat = 0.5):
          #leio X, os parametros ub e lb na funcao dds
          y= np.array_split(X,len(X))
          c1_0,c2_0,c3_0,c4_0,c5_0,c6_0,c7_0,c8_0,c9_0 = z0
          #a ordem de X TEM Q SER IGUAL a dos valores de lb, ub ex: kra = {minimo : 0.005,maximo : 0.8 ...... }
          kra20,fop,krz20,kea,kez,k8320,ez,kgz20,ksa,rpamax,rpamin,kup,kg20,vs3,fd8, rca = y
        

          tempo = 0
          c3_lista = []
          c8_lista = []
          dx = pd.DataFrame()
          

          while tempo < passos:
                temp = T[round(tempo)]


                #equaçoes que variam no passo de tempo
                kgz = (c9_0/(ksa+c9_0))*kgz20*c4_0*w**(temp-20)
                krz = krz20*w**(temp-20)
                k83 = k8320*w**(temp-20)
                kra = kra20*w**(temp-20)
                kg = kg20*wg**(temp-20)
                fup = ((rpamax - rpa)/(rpamax-rpamin)) * (c3_0/(kup+c3_0))
                tempo += deltat
               
                #f_inorg
                c3 = (rpa*kra*(1-fop) * c9_0 + (rpa/rca)*krz*(1-fop)*c4_0 + rpa*kea*(1-fop)*c9_0 -rpa*fup*kg*c9_0+ (rpa/rca)*kez*(1-fop)*c4_0 +k83*c8_0  )*deltat +c3_0
                #f_org
                c8 = (rpa*kra*fop*c9_0 + (rpa/rca)*krz*fop*c4_0 + rpa*kea*fop*c9_0 + (rpa/rca)*kez*fop*c4_0 + rpa*(1-ez)*kgz*c9_0*c4_0 - k83*c8_0 -  - c8_0*(vs3*(1-fd8)/h ))*deltat + c8_0
                #
                


                #mecanismo para aceitar deltat != 1
                resto = tempo % 1
            
        
                if resto != 0:
                  c8_lista.append(float(c8))
                  c3_lista.append(float(c3))
                 
                c3_0 = c3
                
                c8_0 = c8
          dx["f_inorg"] = c3_lista
          dx["f_org"] = c8_lista

          return dx

#reaacao determina qual os parametros de comparacao de qsim e qobs na funcao erro, ou seja qual data frame coletar e com qual comparar
reacao = "fosf"
xbest_f,fbest_f = dds(lb_fo,ub_fo,erro,0.2,5000)
#sucesso é o resultado
sucesso_fo = fosforo(xbest_f,z0,247,0.5)
sim["f_org0"] = sucesso_fo["f_org"]
sim["f_inorg0"] = sucesso_fo["f_inorg"]

